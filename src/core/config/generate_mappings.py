#!/usr/bin/env python3

import json
import re
import sys
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple


class MapConstants:
    """Constants used in the mapping generation process."""
    
    # File paths are relative to script location
    SCHEMA_FILENAME = "descriptor_providers/xlio_config_schema.json"
    OUTPUT_FILENAME = "mappings.py"
    
    # File header comments
    FILE_HEADER = '''#!/usr/bin/env python3

# Mapping of XLIO configuration keys to their corresponding environment variables
# This file is automatically generated from xlio_config_schema.json
# Do not edit manually

'''


class EnvVarExtractor:
    """Handles extraction of environment variables from property descriptions."""
    
    @staticmethod
    def extract_env_var(description: Optional[str]) -> Optional[str]:
        """Extract environment variable name from description.
        
        Args:
            description: The property description text
            
        Returns:
            Environment variable name or None if not found
        """
        if not description:
            return None
        
        if "Maps to " not in description:
            return None
        
        # More flexible regex to match "Maps to XLIO_ABC_DEF environment variable"
        # with potential whitespace or punctuation variations
        match = re.search(r'Maps to\s+([A-Z][A-Z0-9_]+)(?:\s+environment variable|\s+env)', description)
        if match:
            return match.group(1)
        
        # As a fallback, extract the text between "Maps to" and the end of the string or next period
        if "Maps to " in description:
            start_idx = description.index("Maps to ") + 8
            end_idx = description.find(".", start_idx)
            if end_idx == -1:
                end_idx = len(description)
            
            env_var = description[start_idx:end_idx].strip()
            if env_var and re.match(r'^[A-Z][A-Z0-9_]+$', env_var):
                return env_var
                
        return None


class SchemaProcessor:
    """Processes JSON schema and extracts mappings between properties and environment variables."""
    
    def __init__(self):
        self.mappings = {}
        self.sections = {}
    
    def process_schema_file(self, schema_file: str) -> Dict[str, Dict[str, Any]]:
        """Process the JSON schema file and return extracted mappings.
        
        Args:
            schema_file: Path to the JSON schema file
            
        Returns:
            Dictionary with mappings and sections
        """
        with open(schema_file, 'r') as f:
            schema = json.load(f)
        
        # Process each top-level section
        for section_name, section_data in schema.get("properties", {}).items():
            section_mappings, _ = self._process_section(section_data, section_name)
            self.mappings.update(section_mappings)
            self.sections[section_name] = list(section_mappings.keys())
        
        return {
            "mappings": self.mappings,
            "sections": self.sections,
            "schema_sections": list(schema.get("properties", {}).keys())
        }
    
    def _process_section(
        self, 
        schema: Dict[str, Any], 
        parent_path: str = "", 
        result: Optional[Dict[str, str]] = None, 
        section: Optional[str] = None
    ) -> Tuple[Dict[str, str], Optional[str]]:
        """Recursively process schema section to extract mappings.
        
        Args:
            schema: The schema dictionary to process
            parent_path: Current path in the property hierarchy
            result: Accumulator for the extracted mappings
            section: Current section being processed
            
        Returns:
            Tuple of (mappings dictionary, current section)
        """
        if result is None:
            result = {}
        
        # Handle properties at current level
        properties = schema.get("properties", {})
        for prop_name, prop_data in properties.items():
            current_path = f"{parent_path}.{prop_name}" if parent_path else prop_name
            
            # Track the current section
            if not parent_path and section != prop_name:
                section = prop_name
            
            # Check if the property has a description with environment variable mapping
            description = prop_data.get("description", "")
            env_var = EnvVarExtractor.extract_env_var(description)
            
            if env_var:
                result[current_path] = env_var
            
            # Recursively process nested objects
            if prop_data.get("type") == "object":
                self._process_section(prop_data, current_path, result, section)
            if prop_data.get("properties"):
                self._process_section(prop_data, current_path, result, section)
            
            # Handle oneOf with nested properties
            if "oneOf" in prop_data:
                env_var = EnvVarExtractor.extract_env_var(prop_data.get("description", ""))
                if env_var:
                    result[current_path] = env_var
        
        return result, section


class MappingsGenerator:
    """Generates mappings.py file from processed schema data."""
    
    @staticmethod
    def generate_file(output_file: str, schema_data: Dict[str, Any]) -> None:
        """Generate mappings.py file from schema data.
        
        Args:
            output_file: Path to the output file
            schema_data: Processed schema data with mappings and sections
        """
        mappings = schema_data["mappings"]
        schema_sections = schema_data["schema_sections"]
        
        with open(output_file, 'w') as f:
            # Write file header
            f.write(MapConstants.FILE_HEADER)
            
            # Start the mapping dictionary
            f.write('config_mapping = {\n')
            
            # Group mappings by section
            for section in schema_sections:
                f.write(f'    # {section} section\n')
                section_keys = sorted([k for k in mappings.keys() if k.startswith(section)])
                
                for key in section_keys:
                    f.write(f'    "{key}": "{mappings[key]}",\n')
                
                f.write('    \n')
            
            # Remove the last newline and comma if there are sections
            if schema_sections:
                f.seek(f.tell() - 5, 0)
            
            # Close the dictionary
            f.write('\n} \n')


def main():
    """Main entry point for the script."""
    try:
        # Determine file paths
        script_dir = Path(__file__).parent
        schema_file = script_dir / MapConstants.SCHEMA_FILENAME
        output_file = script_dir / MapConstants.OUTPUT_FILENAME
        
        # Validate schema file exists
        if not schema_file.exists():
            print(f"Error: Schema file not found at {schema_file}")
            sys.exit(1)
        
        # Process schema and generate mappings
        processor = SchemaProcessor()
        schema_data = processor.process_schema_file(str(schema_file))
        
        # Generate output file
        MappingsGenerator.generate_file(str(output_file), schema_data)
        
        print(f"Successfully generated {output_file}")
    
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main() 